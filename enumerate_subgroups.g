
# Enumerate subgroups of Sn up to isomorphism
# Generated by enumerate_subgroups.py

startN := 13;
maxN := 13;
dbFile := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/subgroups_db.g";
logFile := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/gap_log.txt";
groupsFile := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/gap_groups.txt";
conjugacyCacheDir := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/conjugacy_cache/";

# ============================================================================
# GroupFingerprint function - computes invariants for a group
# Enhanced with IdSmallGroup for fast identification of small groups
# ============================================================================
GroupFingerprint := function(G)
    local fp, ord, smallId, derivedLen;
    ord := Size(G);
    fp := rec(
        size := ord,
        centerSize := Size(Center(G)),
        derivedSize := Size(DerivedSubgroup(G)),
        frattiniSize := Size(FrattiniSubgroup(G)),
        abelianInvariants := AbelianInvariants(G),
        isAbelian := IsAbelian(G),
        isSolvable := IsSolvable(G),
        isNilpotent := IsNilpotent(G),
        exponent := Exponent(G),
        nrConjugacyClasses := NrConjugacyClasses(G),
        smallGroupId := fail,  # Will be set if available
        derivedLength := fail  # For solvable groups
    );

    # Try to get SmallGroup ID (works for some orders <= 2000)
    # Note: Some orders don't have SmallGroups ID data installed by default
    # These are powers of 2 >= 512, and multiples like 768, 1536
    if ord <= 2000 and ord > 1 and not ord in [512, 768, 1024, 1536] then
        smallId := IdSmallGroup(G);
        if smallId <> fail then
            fp.smallGroupId := smallId;
        fi;
    fi;

    # Derived length for solvable groups (cheap additional invariant)
    if fp.isSolvable then
        fp.derivedLength := DerivedLength(G);
    fi;

    return fp;
end;

# Convert fingerprint to string for hashing
GroupFingerprintKey := function(fp)
    local key, derivedLen;
    # Handle missing derivedLength field from older database entries
    if IsBound(fp.derivedLength) then
        derivedLen := fp.derivedLength;
    else
        derivedLen := fail;
    fi;
    key := Concatenation(
        String(fp.size), "_",
        String(fp.centerSize), "_",
        String(fp.derivedSize), "_",
        String(fp.frattiniSize), "_",
        String(fp.abelianInvariants), "_",
        String(fp.isAbelian), "_",
        String(fp.isSolvable), "_",
        String(fp.isNilpotent), "_",
        String(fp.exponent), "_",
        String(fp.nrConjugacyClasses), "_",
        String(derivedLen)
    );
    # If we have SmallGroupId, append it (makes each bucket size 1!)
    if IsBound(fp.smallGroupId) and fp.smallGroupId <> fail then
        key := Concatenation(key, "_SG", String(fp.smallGroupId));
    fi;
    return key;
end;

# ============================================================================
# Database structure
# ============================================================================
db := rec(
    groups := [],      # List of records
    index := rec()     # fingerprint_key -> [indices]
);

# Statistics
stats := rec(
    totalSubgroups := 0,
    isomorphismTests := 0,
    fingerprintHits := 0
);

# ============================================================================
# Load existing database if it exists
# ============================================================================
LoadDatabase := function(filename)
    local data, entry, G, key, fp, needsRecompute;
    if IsExistingFile(filename) then
        AppendTo(logFile, "Loading existing database from ", filename, "\n");
        data := ReadAsFunction(filename)();
        for entry in data.groups do
            if Length(entry.generators) = 0 then
                G := Group(());
            else
                G := Group(List(entry.generators, PermList));
            fi;
            # Check if fingerprint needs to be recomputed (missing new fields)
            needsRecompute := not IsBound(entry.fingerprint.derivedLength) or
                              not IsBound(entry.fingerprint.smallGroupId);
            if needsRecompute then
                fp := GroupFingerprint(G);
            else
                fp := entry.fingerprint;
            fi;
            key := GroupFingerprintKey(fp);
            Add(db.groups, rec(
                fingerprint := fp,
                generators := entry.generators,
                structure := entry.structure,
                firstFoundIn := entry.firstFoundIn,
                degree := entry.degree
            ));
            if not IsBound(db.index.(key)) then
                db.index.(key) := [];
            fi;
            Add(db.index.(key), Length(db.groups));
        od;
        AppendTo(logFile, "Loaded ", Length(db.groups), " groups from database\n");
    else
        AppendTo(logFile, "No existing database found, starting fresh\n");
    fi;
end;

# ============================================================================
# Add group if new (returns true if added, false if duplicate)
# ============================================================================
AddIfNew := function(G, degree, snName)
    local fp, key, idx, H, entry, gens;

    fp := GroupFingerprint(G);
    key := GroupFingerprintKey(fp);

    # Get generators as image lists
    gens := List(GeneratorsOfGroup(G), p -> ListPerm(p, degree));

    if not IsBound(db.index.(key)) then
        # New fingerprint - definitely a new group
        Add(db.groups, rec(
            fingerprint := fp,
            generators := gens,
            structure := StructureDescription(G),
            firstFoundIn := snName,
            degree := degree
        ));
        db.index.(key) := [Length(db.groups)];
        return true;
    fi;

    # Fingerprint collision - need to check isomorphism
    stats.fingerprintHits := stats.fingerprintHits + 1;

    for idx in db.index.(key) do
        entry := db.groups[idx];
        # Handle empty generators (trivial group)
        if Length(entry.generators) = 0 then
            H := Group(());
        else
            H := Group(List(entry.generators, PermList));
        fi;
        stats.isomorphismTests := stats.isomorphismTests + 1;
        if IsomorphismGroups(G, H) <> fail then
            return false;  # Duplicate
        fi;
    od;

    # New group with existing fingerprint (rare but possible)
    Add(db.groups, rec(
        fingerprint := fp,
        generators := gens,
        structure := StructureDescription(G),
        firstFoundIn := snName,
        degree := degree
    ));
    Add(db.index.(key), Length(db.groups));
    return true;
end;

# ============================================================================
# Save database to file
# ============================================================================
SaveDatabase := function(filename)
    local output;
    output := OutputTextFile(filename, false);
    SetPrintFormattingStatus(output, false);
    PrintTo(output, "return ");
    PrintTo(output, db);
    PrintTo(output, ";\n");
    CloseStream(output);
end;

# ============================================================================
# Main enumeration
# ============================================================================

# Initialize log file
PrintTo(logFile, "Starting enumeration of subgroups of Sn (n = ", startN, " to ", maxN, ")\n");
AppendTo(logFile, "================================================================================\n");

# Load existing database for incremental runs
if startN > 2 then
    LoadDatabase(dbFile);
fi;

startTime := Runtime();

# Helper to write a single group entry to the groups file
WriteGroupEntry := function(idx, entry)
    local G, gens, j;
    AppendTo(groupsFile, "GROUP:", idx, "\n");
    AppendTo(groupsFile, "FIRST_FOUND:", entry.firstFoundIn, "\n");
    AppendTo(groupsFile, "ORDER:", entry.fingerprint.size, "\n");
    AppendTo(groupsFile, "STRUCTURE:", entry.structure, "\n");
    AppendTo(groupsFile, "DEGREE:", entry.degree, "\n");
    AppendTo(groupsFile, "GENERATORS_IMAGE:");
    for j in [1..Length(entry.generators)] do
        AppendTo(groupsFile, entry.generators[j]);
        if j < Length(entry.generators) then
            AppendTo(groupsFile, ";");
        fi;
    od;
    AppendTo(groupsFile, "\n");
    AppendTo(groupsFile, "GENERATORS_CYCLE:");
    if Length(entry.generators) = 0 then
        G := Group(());
    else
        G := Group(List(entry.generators, PermList));
    fi;
    gens := GeneratorsOfGroup(G);
    for j in [1..Length(gens)] do
        AppendTo(groupsFile, gens[j]);
        if j < Length(gens) then
            AppendTo(groupsFile, ", ");
        fi;
    od;
    AppendTo(groupsFile, "\n");
    AppendTo(groupsFile, "GROUP_END\n");
end;

# Initialize groups file with existing groups
PrintTo(groupsFile, "GROUPS_START\n");
for i in [1..Length(db.groups)] do
    WriteGroupEntry(i, db.groups[i]);
od;

lastWrittenGroup := Length(db.groups);

# ============================================================================
# Conjugacy class caching functions
# ============================================================================
# conjugacyCacheDir is now passed as a parameter from Python

SaveConjugacyClasses := function(n, subgroupClasses)
    local filename, output, i, H, gens;
    filename := Concatenation(conjugacyCacheDir, "s", String(n), "_subgroups.g");
    output := OutputTextFile(filename, false);
    SetPrintFormattingStatus(output, false);
    PrintTo(output, "# Conjugacy class representatives for S", n, "\n");
    PrintTo(output, "# ", Length(subgroupClasses), " subgroups\n");
    PrintTo(output, "return [\n");
    for i in [1..Length(subgroupClasses)] do
        H := Representative(subgroupClasses[i]);
        gens := List(GeneratorsOfGroup(H), p -> ListPerm(p, n));
        PrintTo(output, "  ", gens);
        if i < Length(subgroupClasses) then
            PrintTo(output, ",");
        fi;
        PrintTo(output, "\n");
    od;
    PrintTo(output, "];\n");
    CloseStream(output);
end;

LoadConjugacyClasses := function(n)
    local filename, data, subgroups, gens;
    filename := Concatenation(conjugacyCacheDir, "s", String(n), "_subgroups.g");
    if not IsExistingFile(filename) then
        return fail;
    fi;
    data := ReadAsFunction(filename)();
    subgroups := [];
    for gens in data do
        if Length(gens) = 0 then
            Add(subgroups, Group(()));
        else
            Add(subgroups, Group(List(gens, PermList)));
        fi;
    od;
    return subgroups;
end;

SaveProgressIndex := function(n, idx)
    local filename;
    filename := Concatenation(conjugacyCacheDir, "s", String(n), "_progress.txt");
    PrintTo(filename, idx);
end;

LoadProgressIndex := function(n)
    local filename, idx;
    filename := Concatenation(conjugacyCacheDir, "s", String(n), "_progress.txt");
    if not IsExistingFile(filename) then
        return 1;
    fi;
    idx := Int(ReadAll(InputTextFile(filename)));
    return idx;
end;

ClearProgressIndex := function(n)
    local filename;
    filename := Concatenation(conjugacyCacheDir, "s", String(n), "_progress.txt");
    if IsExistingFile(filename) then
        RemoveFile(filename);
    fi;
end;

# Create cache directory
Exec(Concatenation("mkdir -p ", conjugacyCacheDir));

for n in [startN..maxN] do
    AppendTo(logFile, "Processing S", n, "...\n");

    Sn := SymmetricGroup(n);
    snName := Concatenation("S", String(n));

    # Try to load cached conjugacy classes, or compute them
    subgroups := LoadConjugacyClasses(n);
    if subgroups <> fail then
        AppendTo(logFile, "  Loaded ", Length(subgroups), " cached subgroups\n");
        nSubgroups := Length(subgroups);
        startIdx := LoadProgressIndex(n);
        if startIdx > 1 then
            AppendTo(logFile, "  Resuming from index ", startIdx, "\n");
        fi;
    else
        AppendTo(logFile, "  Computing conjugacy classes of subgroups...\n");
        subgroupClasses := ConjugacyClassesSubgroups(Sn);
        nSubgroups := Length(subgroupClasses);
        # Convert to list of groups and cache
        subgroups := List(subgroupClasses, Representative);
        SaveConjugacyClasses(n, subgroupClasses);
        AppendTo(logFile, "  Cached ", nSubgroups, " subgroups to disk\n");
        startIdx := 1;
    fi;

    stats.totalSubgroups := stats.totalSubgroups + nSubgroups;
    AppendTo(logFile, "  Found ", nSubgroups, " subgroups (up to conjugacy)\n");

    newCount := 0;
    for i in [startIdx..nSubgroups] do
        H := subgroups[i];
        if AddIfNew(H, n, snName) then
            newCount := newCount + 1;

            # Write new group immediately (crash-safe)
            WriteGroupEntry(Length(db.groups), db.groups[Length(db.groups)]);
            lastWrittenGroup := Length(db.groups);
        fi;

        # Progress update and checkpoint every 100 subgroups
        if i mod 100 = 0 then
            AppendTo(logFile, "    Processed ", i, "/", nSubgroups, " subgroups (", Length(db.groups), " unique groups, checkpoint saved)\n");
            SaveProgressIndex(n, i + 1);
            SaveDatabase(dbFile);
        fi;
    od;

    # Groups are now written immediately, no need for batch write

    elapsed := Float(Runtime() - startTime) / 1000.0;
    AppendTo(logFile, "  New groups added: ", newCount, "\n");
    AppendTo(logFile, "  Total unique groups so far: ", Length(db.groups), "\n");
    AppendTo(logFile, "  Time elapsed: ", elapsed, "s\n");
    AppendTo(logFile, "--------------------------------------------------------------------------------\n");

    # Save database and clear progress (Sn complete)
    SaveDatabase(dbFile);
    ClearProgressIndex(n);
    AppendTo(logFile, "  Database checkpoint saved to ", dbFile, "\n");
od;

# ============================================================================
# Output results
# ============================================================================
AppendTo(logFile, "================================================================================\n");
AppendTo(logFile, "SUMMARY\n");
AppendTo(logFile, "Total subgroups processed: ", stats.totalSubgroups, "\n");
AppendTo(logFile, "Total unique groups: ", Length(db.groups), "\n");
AppendTo(logFile, "Fingerprint collisions: ", stats.fingerprintHits, "\n");
AppendTo(logFile, "Isomorphism tests performed: ", stats.isomorphismTests, "\n");
totalTime := Float(Runtime() - startTime) / 1000.0;
AppendTo(logFile, "Total time: ", totalTime, "s\n");
AppendTo(logFile, "================================================================================\n");

# ============================================================================
# Finalize groups file (groups were written incrementally above)
# ============================================================================
AppendTo(groupsFile, "GROUPS_END\n");

AppendTo(logFile, "DONE\n");

QUIT;
