"""
Step 11: Regenerate test_groups_static.g
Runs test_groups_source.g through GAP to produce test_groups_generated.g,
then combines with EXPECTED pairs to create final test_groups_static.g.
"""
import subprocess
import os
from datetime import datetime

GAP_BASH = r"C:\Program Files\GAP-4.15.1\runtime\bin\bash.exe"
BASE_DIR = r"C:\Users\jeffr\Downloads\Symmetric Groups\Partition\tests"

# Cygwin paths
source_script = "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/Partition/tests/test_groups_source.g"
generated_file = os.path.join(BASE_DIR, "test_groups_generated.g")
static_file = os.path.join(BASE_DIR, "test_groups_static.g")
output_log = os.path.join(BASE_DIR, "regenerate_static_output.txt")

print(f"=== Regenerating test_groups_static.g ===")
print(f"Started: {datetime.now()}")
print()

# Step 1: Run test_groups_source.g through GAP
cmd = [GAP_BASH, "--login", "-c", f'/opt/gap-4.15.1/gap -q "{source_script}"']

print("Running GAP to generate test groups...")
with open(output_log, "w") as out:
    out.write(f"# Started at {datetime.now()}\n\n")
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
    for line in proc.stdout:
        print(line, end='')
        out.write(line)
        out.flush()
    proc.wait()
    out.write(f"\n# Finished at {datetime.now()}\n")
    out.write(f"# Exit code: {proc.returncode}\n")

if proc.returncode != 0:
    print(f"\nERROR: GAP exited with code {proc.returncode}")
    exit(1)

# Step 2: Read the generated file
print("\nReading generated file...")
with open(generated_file, "r") as f:
    generated_content = f.read()

# Step 3: Build the static file with proper header and EXPECTED pairs
header = """# Static Test Groups for Factor Comparison Test Suite
# Generated by test_groups_source.g via regenerate_static.py
# These groups can be loaded directly for testing without computing invariants
#
# Usage: Read("test_groups_static.g");
#        G := TEST_GROUPS_STATIC[1].group;
#
# Fields per group:
#   source, originalIndex, combinedIndex, index, testName - identification
#   sigKey - [order, derivedSize, numClasses, derivedLength, abelianInvs]
#   order - group order
#   isDirectProduct, factors, factorOrders, numFactors - direct product info
#   factorGens - generator strings for ALL direct factors (positional with factors)
#   histogram - element order histogram [[order, count], ...]
#   maxOrder - maximum element order (exponent)
#   numOrders - number of distinct element orders
#
# Groups organized by test concern:
#   Part1_*: Pure direct products
#   Part2_*: Single semidirect factor
#   Part3_*: Multiple semidirect factors (bucket 54 pattern)
#   Concern1_*: Pure factor mismatch with semidirect
#   Concern2_*: Greedy matching robustness
#   Edge_*: Edge cases

Print("Loading static test groups with full invariants...\\n");

"""

# Transform TEST_GROUPS_GENERATED -> TEST_GROUPS_STATIC
static_content = generated_content.replace("TEST_GROUPS_GENERATED", "TEST_GROUPS_STATIC")

# Add the expected pairs at the end
expected_pairs = """
#-------------------------------------------------------------------
# Expected Test Results
#-------------------------------------------------------------------

# Pairs that should be isomorphic (expected := true)
EXPECTED_ISOMORPHIC_PAIRS := [
  [1, 2],   # Part1_C2_x_S4 = Part1_S4_x_C2
  [16, 27], # Concern1_C2_x_C3_x_D8 = Concern1_C3_x_C2_x_D8
  [29, 30], # Concern2_D8_x_Q8 = Concern2_Q8_x_D8
  [31, 32], # Concern2_D8_x_D8_x_Q8 = Concern2_Q8_x_D8_x_D8
  [33, 34], # Concern2_C2_x_C3_x_D8_x_Q8 = Concern2_C3_x_Q8_x_C2_x_D8
  [29, 37], # Concern2_D8_x_Q8 = Concern2_Dihedral8_x_Quaternion8
];

# Pairs that should NOT be isomorphic (expected := false)
EXPECTED_NONISOMORPHIC_PAIRS := [
  [1, 5],   # C2 x S4 vs C3 x S4
  [6, 7],   # D8 x C3 vs Q8 x C3
  [8, 9],   # D8 x C5 vs D8 x C7
  [11, 12], # Bucket54 pattern: SG32_6 vs SG32_7
  [16, 17], # Concern1: C2 x C3 x D8 vs C2 x C5 x D8
  [18, 19], # Concern1: C2 x C2 x C3 x D8 vs C2 x C2 x C7 x D8
  [20, 21], # Concern1: C3 x D8 x Q8 vs C5 x D8 x Q8
  [16, 22], # Concern1: same pure, semi D8 vs Q8
  [23, 24], # Concern1: C3 x D8 vs C5 x D8
  [25, 26], # Concern1: C3 x C5 x D8 vs C7 x C11 x D8
  [28, 29], # Concern2: D8 x D8 vs D8 x Q8
  [35, 36], # Concern2: D8 x D16 vs Q8 x QD16
];

Print("Loaded ", Length(TEST_GROUPS_STATIC), " test groups with full invariants\\n");
Print("Expected isomorphic pairs: ", Length(EXPECTED_ISOMORPHIC_PAIRS), "\\n");
Print("Expected non-isomorphic pairs: ", Length(EXPECTED_NONISOMORPHIC_PAIRS), "\\n");
"""

with open(static_file, "w") as f:
    f.write(header)
    f.write(static_content)
    f.write(expected_pairs)

print(f"\nWrote {static_file}")

# Step 4: Verify the output
with open(static_file, "r") as f:
    content = f.read()

n_groups = content.count("testName :=")
n_factorGens = content.count("factorGens :=")
n_isDP = content.count("isDirectProduct := true")

print(f"\nVerification:")
print(f"  Total groups: {n_groups}")
print(f"  Direct products: {n_isDP}")
print(f"  Records with factorGens: {n_factorGens}")
print(f"  EXPECTED_ISOMORPHIC_PAIRS present: {'EXPECTED_ISOMORPHIC_PAIRS' in content}")
print(f"  EXPECTED_NONISOMORPHIC_PAIRS present: {'EXPECTED_NONISOMORPHIC_PAIRS' in content}")
print(f"  No ambiguousFactorGens: {'ambiguousFactorGens' not in content}")

print(f"\n=== COMPLETE at {datetime.now()} ===")
