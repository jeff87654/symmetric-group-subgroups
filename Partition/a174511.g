###############################################################################
#
# a174511.g - Compute OEIS A174511: Isomorphism types of subgroups of S_n
#
# This implements Derek Holt's partition-based approach for efficiently
# enumerating subgroups of symmetric groups.
#
# Usage:
#   gap> Read("a174511.g");
#   gap> ComputeA174511(8);   # Returns 137
#
# For large n (>= 12), run from command line with extra memory:
#   gap -o 16g -c "Read(\"a174511.g\"); ComputeA174511(14);"
#
###############################################################################

# Global variable for log file path
A174511_LOG_FILE := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/Partition/partition_log.txt";

# Global variable for output file path (group generators)
A174511_OUTPUT_FILE := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/Partition/groups_output.txt";

# Global variable for cache directory
A174511_CACHE_DIR := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/Partition/cache/";

# Global variable for checkpoint file
A174511_CHECKPOINT_FILE := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups/Partition/checkpoint.g";

# Global list to store group representatives (for output)
A174511_GROUPS := [];

# Save checkpoint after each partition
SaveCheckpoint := function(n, completedPartitions, seenTypes, largeGroups, largeGroupTypes)
    local f, g, gens, gen, part;
    f := OutputTextFile(A174511_CHECKPOINT_FILE, false);

    PrintTo(f, "# Checkpoint for S_", n, " computation\n");
    PrintTo(f, "# Completed partitions: ", Length(completedPartitions), "\n\n");

    PrintTo(f, "A174511_CHECKPOINT_N := ", n, ";\n\n");

    # Save completed partitions
    PrintTo(f, "A174511_CHECKPOINT_COMPLETED := [\n");
    for part in completedPartitions do
        PrintTo(f, "  ", part, ",\n");
    od;
    PrintTo(f, "];\n\n");

    # Save seenTypes as a list of strings (will rebuild record on load)
    PrintTo(f, "A174511_CHECKPOINT_SEEN_LIST := [\n");
    for g in RecNames(seenTypes) do
        PrintTo(f, "  \"", g, "\",\n");
    od;
    PrintTo(f, "];\n\n");

    # Save largeGroups (pending deduplication)
    PrintTo(f, "A174511_CHECKPOINT_LARGE_GROUPS := [\n");
    for g in largeGroups do
        gens := GeneratorsOfGroup(g);
        PrintTo(f, "  Group(");
        for gen in [1..Length(gens)] do
            PrintTo(f, gens[gen]);
            if gen < Length(gens) then PrintTo(f, ", "); fi;
        od;
        PrintTo(f, "),\n");
    od;
    PrintTo(f, "];\n\n");

    # Save largeGroupTypes (already deduplicated from S_{n-1})
    PrintTo(f, "A174511_CHECKPOINT_LARGE_TYPES := [\n");
    for g in largeGroupTypes do
        gens := GeneratorsOfGroup(g);
        PrintTo(f, "  Group(");
        for gen in [1..Length(gens)] do
            PrintTo(f, gens[gen]);
            if gen < Length(gens) then PrintTo(f, ", "); fi;
        od;
        PrintTo(f, "),\n");
    od;
    PrintTo(f, "];\n");

    CloseStream(f);
end;

# Load checkpoint (returns fail if not found or wrong n)
LoadCheckpoint := function(n)
    local seenTypes, s;
    if IsExistingFile(A174511_CHECKPOINT_FILE) then
        Read(A174511_CHECKPOINT_FILE);
        if IsBound(A174511_CHECKPOINT_N) and A174511_CHECKPOINT_N = n then
            Print("  Resuming from checkpoint: ", Length(A174511_CHECKPOINT_COMPLETED),
                  " partitions completed\n");
            WriteToLog(Concatenation("Resuming from checkpoint: ",
                       String(Length(A174511_CHECKPOINT_COMPLETED)), " partitions done"));
            # Rebuild seenTypes record from list
            seenTypes := rec();
            for s in A174511_CHECKPOINT_SEEN_LIST do
                seenTypes.(s) := true;
            od;
            return rec(
                completedPartitions := A174511_CHECKPOINT_COMPLETED,
                seenTypes := seenTypes,
                largeGroups := A174511_CHECKPOINT_LARGE_GROUPS,
                largeGroupTypes := A174511_CHECKPOINT_LARGE_TYPES
            );
        fi;
    fi;
    return fail;
end;

# Clear checkpoint file
ClearCheckpoint := function()
    if IsExistingFile(A174511_CHECKPOINT_FILE) then
        RemoveFile(A174511_CHECKPOINT_FILE);
    fi;
end;

# Save cache for a given n
SaveCache := function(n, seenTypes, largeGroupTypes)
    local filename, f, g, gens, gen;
    filename := Concatenation(A174511_CACHE_DIR, "s", String(n), "_cache.g");
    f := OutputTextFile(filename, false);

    # Write header
    PrintTo(f, "# Cache for S_", n, "\n");
    PrintTo(f, "# Generated by A174511 computation\n\n");

    # Write seenTypes as a list of strings (will rebuild record on load)
    PrintTo(f, "A174511_CACHED_SEEN_LIST := [\n");
    for g in RecNames(seenTypes) do
        PrintTo(f, "  \"", g, "\",\n");
    od;
    PrintTo(f, "];\n\n");

    # Write large group types with generators
    PrintTo(f, "A174511_CACHED_LARGE_GROUPS := [\n");
    for g in largeGroupTypes do
        gens := GeneratorsOfGroup(g);
        PrintTo(f, "  Group(");
        for gen in [1..Length(gens)] do
            PrintTo(f, gens[gen]);
            if gen < Length(gens) then
                PrintTo(f, ", ");
            fi;
        od;
        PrintTo(f, "),\n");
    od;
    PrintTo(f, "];\n");

    CloseStream(f);
    Print("  Saved cache for S_", n, " to ", filename, "\n");
end;

# Load cache for a given n (returns fail if not found)
LoadCache := function(n)
    local filename, seenTypes, s;
    filename := Concatenation(A174511_CACHE_DIR, "s", String(n), "_cache.g");

    if IsExistingFile(filename) then
        Read(filename);
        Print("  Loaded cache for S_", n, " from ", filename, "\n");
        # Rebuild seenTypes record from list
        seenTypes := rec();
        for s in A174511_CACHED_SEEN_LIST do
            seenTypes.(s) := true;
        od;
        return rec(
            seenTypes := seenTypes,
            largeGroupTypes := A174511_CACHED_LARGE_GROUPS
        );
    else
        return fail;
    fi;
end;

# Write a group to the output file
WriteGroupToFile := function(G, typeId)
    local f, gens, g;
    f := OutputTextFile(A174511_OUTPUT_FILE, true);  # append mode
    AppendTo(f, "# Type: ", typeId, " | Order: ", Size(G), "\n");
    gens := GeneratorsOfGroup(G);
    for g in gens do
        AppendTo(f, g, "\n");
    od;
    AppendTo(f, "\n");
    CloseStream(f);
end;

# Initialize output file
InitOutputFile := function(n)
    local f;
    f := OutputTextFile(A174511_OUTPUT_FILE, false);  # overwrite
    PrintTo(f, "# A174511 Groups for S_", n, "\n");
    PrintTo(f, "# Format: Each group has a Type line followed by generators\n");
    PrintTo(f, RepeatedString("#", 60), "\n\n");
    CloseStream(f);
end;

# Write a status line to the log file
WriteToLog := function(msg)
    local f;
    f := OutputTextFile(A174511_LOG_FILE, true);  # true = append mode
    AppendTo(f, msg, "\n");
    CloseStream(f);
end;

# Initialize log file for a new computation
InitLogFile := function(n)
    local f;
    f := OutputTextFile(A174511_LOG_FILE, false);  # false = overwrite
    PrintTo(f, "A174511 Computation Log for n=", n, "\n");
    PrintTo(f, "Started: ", StringTime(Runtime()), "\n");
    PrintTo(f, RepeatedString("=", 60), "\n\n");
    CloseStream(f);
end;

# Check if IdGroup is available for a given order
# The SmallGroups library has gaps at certain orders
IdGroupAvailable := function(ord)
    if ord > 2000 then return false; fi;
    if ord = 0 then return false; fi;
    # Orders where SmallGroups ID data is not available by default
    if ord in [512, 768, 1024, 1536] then return false; fi;
    # Check if IdGroupsAvailable function exists (GAP version dependent)
    if IsBound(IdGroupsAvailable) then
        return IdGroupsAvailable(ord);
    fi;
    # Fallback: assume available for small orders
    return ord <= 2000;
end;

# Get a canonical identifier for a group's isomorphism type
# Returns either IdGroup (if available) or a structural invariant
GetGroupTypeId := function(G)
    local ord;
    ord := Size(G);
    if IdGroupAvailable(ord) then
        return IdGroup(G);
    else
        # For large groups, return a tuple of invariants
        # This may not uniquely identify the group, requiring pairwise testing later
        return [ord, "large"];
    fi;
end;

###############################################################################
# Partition generation
###############################################################################

# Generate all partitions of n with minimum part >= minpart
# Returns list of lists, each in non-increasing order
PartitionsMinPart := function(n, minpart)
    local result, helper;
    
    helper := function(remaining, maxpart, current)
        local i;
        if remaining = 0 then
            Add(result, ShallowCopy(current));
            return;
        fi;
        for i in [Minimum(remaining, maxpart), Minimum(remaining, maxpart)-1 .. minpart] do
            Add(current, i);
            helper(remaining - i, i, current);
            Remove(current);
        od;
    end;
    
    result := [];
    helper(n, n, []);
    return result;
end;

###############################################################################
# Subdirect products
###############################################################################

# Find all subdirect products of two groups G and H
# A subdirect product is a subgroup of G x H that projects onto both G and H
MySubdirectProductsOfTwo := function(G, H)
    local D, result, allSubs, S, proj1, proj2;

    D := DirectProduct(G, H);
    proj1 := Projection(D, 1);
    proj2 := Projection(D, 2);

    # Get all subgroups of the direct product
    allSubs := List(ConjugacyClassesSubgroups(D), Representative);

    # Filter to those projecting onto both factors
    result := [];
    for S in allSubs do
        if Size(Image(proj1, S)) = Size(G) and Size(Image(proj2, S)) = Size(H) then
            Add(result, S);
        fi;
    od;

    return result;
end;

# Find subdirect products of a list of groups
# For efficiency, we do this iteratively: ((G1 x G2) x G3) x ...
MySubdirectProducts := function(factors)
    local result, i, newResult, P, S, T;
    
    if Length(factors) = 0 then
        return [TrivialGroup()];
    fi;
    
    if Length(factors) = 1 then
        return [factors[1]];
    fi;
    
    # Start with subdirect products of first two factors
    result := MySubdirectProductsOfTwo(factors[1], factors[2]);
    
    # Iteratively extend with remaining factors
    for i in [3..Length(factors)] do
        newResult := [];
        for P in result do
            for S in MySubdirectProductsOfTwo(P, factors[i]) do
                Add(newResult, S);
            od;
        od;
        result := newResult;
        
        # Memory management for large computations
        if Length(result) > 10000 then
            GASMAN("collect");
        fi;
    od;
    
    return result;
end;

###############################################################################
# Processing partitions
###############################################################################

# Process a single partition and collect isomorphism types
# seenTypes is a record mapping type IDs to true (for deduplication)
# largeGroups is a list collecting groups that need pairwise testing
ProcessPartition := function(partition, seenTypes, largeGroups)
    local transitiveLists, combo, nCombos, count, factors, subdirects, S, typeId, i,
          startTypes, startTime;

    startTypes := Length(RecNames(seenTypes));
    startTime := Runtime();

    # Get all transitive groups for each part of the partition
    transitiveLists := List(partition, d ->
        List([1..NrTransitiveGroups(d)], i -> TransitiveGroup(d, i)));

    # Count total combinations for progress reporting
    nCombos := Product(List(transitiveLists, Length));

    Print("    Partition ", partition, ": ", nCombos, " combinations...");

    # Log at start of partition processing
    WriteToLog(Concatenation(
        "STARTED: Partition ", String(partition),
        " | Combinations: ", String(nCombos),
        " | Current types: ", String(startTypes)
    ));

    # Iterate over all combinations of transitive groups
    # Use a recursive approach to handle variable-length partitions
    count := 0;

    # Helper to iterate through all combinations
    IterateCombinations := function(depth, currentFactors)
        local T, subdirects, S, typeId;

        if depth > Length(transitiveLists) then
            # Process this combination of factors
            count := count + 1;

            if nCombos > 100 and count mod 100 = 0 then
                Print("\r    Partition ", partition, ": ", count, "/", nCombos,
                      " (", Length(RecNames(seenTypes)) - startTypes, " new types)   ");
            fi;

            # Find all subdirect products (with error handling for GAP bugs)
            subdirects := CALL_WITH_CATCH(MySubdirectProducts, [currentFactors]);
            if subdirects[1] = false then
                # Error occurred - log and skip this combination
                Print("\n      WARNING: Skipping combination ", count,
                      " due to GAP error\n");
                WriteToLog(Concatenation("WARNING: Skipped combination ",
                           String(count), " in partition ", String(partition)));
                return;
            fi;
            subdirects := subdirects[2];

            for S in subdirects do
                typeId := GetGroupTypeId(S);
                if typeId[2] = "large" then
                    # Need pairwise testing later
                    Add(largeGroups, S);
                else
                    # Can use IdGroup for deduplication
                    if not IsBound(seenTypes.(String(typeId))) then
                        seenTypes.(String(typeId)) := true;
                        # Save representative and write to file
                        Add(A174511_GROUPS, S);
                        WriteGroupToFile(S, typeId);
                    fi;
                fi;
            od;
            return;
        fi;

        for T in transitiveLists[depth] do
            Add(currentFactors, T);
            IterateCombinations(depth + 1, currentFactors);
            Remove(currentFactors);
        od;
    end;

    IterateCombinations(1, []);

    Print("\r    Partition ", partition, ": done, ",
          Length(RecNames(seenTypes)) - startTypes, " new types, ",
          (Runtime() - startTime)/1000.0, "s\n");

    # Write to log file
    WriteToLog(Concatenation(
        "DONE:    Partition ", String(partition),
        " | New types: ", String(Length(RecNames(seenTypes)) - startTypes),
        " | Total types: ", String(Length(RecNames(seenTypes))),
        " | Time: ", String((Runtime() - startTime)/1000.0), "s"
    ));
end;

###############################################################################
# Main computation
###############################################################################

# Compute A174511(n) - number of isomorphism types of subgroups of S_n
# Uses the partition-based approach for efficiency
ComputeA174511 := function(n)
    local seenTypes, largeGroups, partitions, part, T, g, h, flag, 
          startTime, nSmall, nLarge;
    
    startTime := Runtime();
    Print("Computing A174511(", n, ")...\n");
    
    # Record to track seen IdGroup values
    seenTypes := rec();
    
    # List for groups needing pairwise isomorphism testing
    largeGroups := [];
    
    # Always include the trivial group
    seenTypes.(String([1,1])) := true;
    
    # Process partitions of n with minimum part 1 (i.e., all partitions)
    # But we handle fixed points differently...
    
    # Actually, for correctness we use the simpler recursive structure:
    # Subgroups of S_n = Subgroups of S_{n-1} ∪ {fix-point-free subgroups of S_n}
    
    if n = 1 then
        return 1;
    fi;
    
    # First, include all types from S_{n-1}
    Print("Including types from S_", n-1, "...\n");
    
    # Instead of recursion (which would be slow), we use the direct approach
    # for small n and build up
    
    # For the implementation, we'll compute directly using ConjugacyClassesSubgroups
    # for small n, and the partition method for larger n
    
    if n <= 10 then
        # Direct computation is feasible for small n
        return ComputeA174511Direct(n);
    else
        # Use partition-based method
        return ComputeA174511Partitioned(n);
    fi;
end;

# Direct computation for small n (n <= 10)
ComputeA174511Direct := function(n)
    local G, R, RR, seenTypes, largeGroups, g, typeId, T, h, flag, count;
    
    Print("Using direct method for n=", n, "\n");
    
    G := SymmetricGroup(n);
    R := ConjugacyClassesSubgroups(G);
    RR := List(R, Representative);
    Print("Found ", Length(RR), " conjugacy classes\n");
    
    seenTypes := rec();
    largeGroups := [];
    
    for g in RR do
        typeId := GetGroupTypeId(g);
        if typeId[2] = "large" then
            Add(largeGroups, g);
        else
            if not IsBound(seenTypes.(String(typeId))) then
                seenTypes.(String(typeId)) := true;
            fi;
        fi;
    od;
    
    Print("Types with IdGroup: ", Length(RecNames(seenTypes)), "\n");
    Print("Groups needing pairwise testing: ", Length(largeGroups), "\n");
    
    # Pairwise testing for large groups
    T := [];
    count := 0;
    for g in largeGroups do
        count := count + 1;
        flag := false;
        for h in T do
            if Size(h) = Size(g) and IsomorphismGroups(g, h) <> fail then
                flag := true;
                break;
            fi;
        od;
        if not flag then
            Add(T, g);
        fi;
    od;
    
    Print("Distinct large group types: ", Length(T), "\n");
    
    return Length(RecNames(seenTypes)) + Length(T);
end;

# Partition-based computation for larger n
ComputeA174511Partitioned := function(n)
    local seenTypes, largeGroups, partitions, part, T, g, h, flag,
          smallerTypes, smaller, startTime, checkpoint, completedPartitions,
          largeGroupTypes, i;

    startTime := Runtime();

    # Initialize log and output files (append mode if resuming)
    checkpoint := LoadCheckpoint(n);
    if checkpoint = fail then
        InitLogFile(n);
        InitOutputFile(n);
        A174511_GROUPS := [];
        WriteToLog(Concatenation("Computing A174511(", String(n), ")"));

        # First get all types from S_{n-1}
        Print("Computing types from S_", n-1, "...\n");
        smaller := ComputeA174511Partitioned_Helper(n-1);
        seenTypes := smaller.seenTypes;
        largeGroups := ShallowCopy(smaller.largeGroups);
        largeGroupTypes := ShallowCopy(smaller.largeGroupTypes);
        completedPartitions := [];

        Print("Types from S_", n-1, ": ", Length(RecNames(seenTypes)), " (IdGroup) + ",
              Length(largeGroupTypes), " (large)\n");

        WriteToLog(Concatenation(
            "Types from S_", String(n-1), ": ",
            String(Length(RecNames(seenTypes))), " (IdGroup) + ",
            String(Length(largeGroupTypes)), " (large)"
        ));
    else
        # Resume from checkpoint
        seenTypes := checkpoint.seenTypes;
        largeGroups := checkpoint.largeGroups;
        largeGroupTypes := checkpoint.largeGroupTypes;
        completedPartitions := checkpoint.completedPartitions;
        Print("Resumed with ", Length(RecNames(seenTypes)), " IdGroup types, ",
              Length(largeGroups), " pending large groups\n");
    fi;

    # Now process fix-point-free partitions of n
    partitions := PartitionsMinPart(n, 2);
    Print("Processing ", Length(partitions), " fix-point-free partitions of ", n, "...\n");
    if checkpoint = fail then
        WriteToLog(Concatenation("\nProcessing ", String(Length(partitions)),
                   " fix-point-free partitions of ", String(n), ":"));
    fi;

    for i in [1..Length(partitions)] do
        part := partitions[i];
        # Skip already completed partitions
        if part in completedPartitions then
            Print("Partition: ", part, " (already done, skipping)\n");
            continue;
        fi;

        Print("Partition ", i, "/", Length(partitions), ": ", part, "\n");
        ProcessPartition(part, seenTypes, largeGroups);
        Add(completedPartitions, part);

        # Save checkpoint after each partition
        SaveCheckpoint(n, completedPartitions, seenTypes, largeGroups, largeGroupTypes);
        GASMAN("collect");
    od;
    
    Print("After all partitions:\n");
    Print("  Types with IdGroup: ", Length(RecNames(seenTypes)), "\n");
    Print("  Groups needing pairwise testing: ", Length(largeGroups), "\n");

    # Pairwise testing for large groups
    T := ShallowCopy(largeGroupTypes);
    for g in largeGroups do
        flag := false;
        for h in T do
            if Size(h) = Size(g) and IsomorphismGroups(g, h) <> fail then
                flag := true;
                break;
            fi;
        od;
        if not flag then
            Add(T, g);
            # Write large group to file
            Add(A174511_GROUPS, g);
            WriteGroupToFile(g, [Size(g), "large"]);
        fi;
    od;

    Print("Total large group types: ", Length(T), "\n");
    Print("Total time: ", (Runtime() - startTime)/1000.0, " seconds\n");

    # Write final results to log
    WriteToLog(Concatenation("\n", RepeatedString("=", 60)));
    WriteToLog(Concatenation("FINAL RESULT: a(", String(n), ") = ",
               String(Length(RecNames(seenTypes)) + Length(T))));
    WriteToLog(Concatenation("  IdGroup types: ", String(Length(RecNames(seenTypes)))));
    WriteToLog(Concatenation("  Large group types: ", String(Length(T))));
    WriteToLog(Concatenation("  Groups written to file: ", String(Length(A174511_GROUPS))));
    WriteToLog(Concatenation("  Total time: ", String((Runtime() - startTime)/1000.0), " seconds"));
    WriteToLog(Concatenation("Output file: ", A174511_OUTPUT_FILE));

    # Clear checkpoint on successful completion
    ClearCheckpoint();
    Print("Checkpoint cleared.\n");

    return Length(RecNames(seenTypes)) + Length(T);
end;

# Helper that returns both the count and the data structures
ComputeA174511Partitioned_Helper := function(n)
    local G, R, RR, seenTypes, largeGroups, g, typeId, T, h, flag,
          smaller, partitions, part, cached, result;

    # Try to load from cache first
    cached := LoadCache(n);
    if cached <> fail then
        WriteToLog(Concatenation("Loaded S_", String(n), " from cache: ",
                   String(Length(RecNames(cached.seenTypes))), " IdGroup + ",
                   String(Length(cached.largeGroupTypes)), " large"));
        return rec(seenTypes := cached.seenTypes, largeGroups := [],
                   largeGroupTypes := cached.largeGroupTypes);
    fi;

    if n <= 10 then
        # Use direct method and return structures
        G := SymmetricGroup(n);
        R := ConjugacyClassesSubgroups(G);
        RR := List(R, Representative);

        seenTypes := rec();
        largeGroups := [];

        for g in RR do
            typeId := GetGroupTypeId(g);
            if typeId[2] = "large" then
                Add(largeGroups, g);
            else
                if not IsBound(seenTypes.(String(typeId))) then
                    seenTypes.(String(typeId)) := true;
                    # Write to output file
                    Add(A174511_GROUPS, g);
                    WriteGroupToFile(g, typeId);
                fi;
            fi;
        od;

        # Deduplicate large groups
        T := [];
        for g in largeGroups do
            flag := false;
            for h in T do
                if Size(h) = Size(g) and IsomorphismGroups(g, h) <> fail then
                    flag := true;
                    break;
                fi;
            od;
            if not flag then
                Add(T, g);
                # Write large group to output file
                Add(A174511_GROUPS, g);
                WriteGroupToFile(g, [Size(g), "large"]);
            fi;
        od;

        # Save to cache
        SaveCache(n, seenTypes, T);
        return rec(seenTypes := seenTypes, largeGroups := [], largeGroupTypes := T);
    else
        # Recursive case: build on S_{n-1} results
        Print("Computing types for n=", n, " using partition method...\n");
        WriteToLog(Concatenation("\n--- Building types for S_", String(n), " ---"));

        # Get all types from S_{n-1}
        smaller := ComputeA174511Partitioned_Helper(n - 1);
        seenTypes := smaller.seenTypes;
        largeGroups := [];
        T := ShallowCopy(smaller.largeGroupTypes);

        Print("  Inherited ", Length(RecNames(seenTypes)), " IdGroup types and ",
              Length(T), " large types from S_", n-1, "\n");
        WriteToLog(Concatenation("Inherited from S_", String(n-1), ": ",
                   String(Length(RecNames(seenTypes))), " IdGroup + ",
                   String(Length(T)), " large"));

        # Process fix-point-free partitions of n (min part >= 2)
        partitions := PartitionsMinPart(n, 2);
        Print("  Processing ", Length(partitions), " fix-point-free partitions...\n");
        WriteToLog(Concatenation("Processing ", String(Length(partitions)),
                   " fix-point-free partitions of ", String(n), ":"));

        for part in partitions do
            ProcessPartition(part, seenTypes, largeGroups);
        od;

        Print("  After partitions: ", Length(RecNames(seenTypes)), " IdGroup types, ",
              Length(largeGroups), " large groups to test\n");

        # Deduplicate new large groups against existing T
        for g in largeGroups do
            flag := false;
            for h in T do
                if Size(h) = Size(g) and IsomorphismGroups(g, h) <> fail then
                    flag := true;
                    break;
                fi;
            od;
            if not flag then
                Add(T, g);
                # Write large group to output file
                Add(A174511_GROUPS, g);
                WriteGroupToFile(g, [Size(g), "large"]);
            fi;
        od;

        # Save to cache
        SaveCache(n, seenTypes, T);

        GASMAN("collect");
        return rec(seenTypes := seenTypes, largeGroups := [], largeGroupTypes := T);
    fi;
end;

###############################################################################
# Simplified version for testing
###############################################################################

# Simple but slower version that definitely works
# Good for verification on small n
ComputeA174511Simple := function(n)
    local G, R, RR, T, g, h, flag;
    
    G := SymmetricGroup(n);
    R := ConjugacyClassesSubgroups(G);
    RR := List(R, Representative);
    
    T := [RR[1]];
    for g in RR do
        flag := false;
        for h in T do
            if IsomorphismGroups(g, h) <> fail then
                flag := true;
                break;
            fi;
        od;
        if not flag then
            Add(T, g);
        fi;
    od;
    
    return Length(T);
end;

###############################################################################
# Test function
###############################################################################

TestA174511 := function(maxN)
    local known, n, result;
    
    # Known values from OEIS
    known := [1, 2, 4, 9, 16, 29, 55, 137, 241, 453, 894, 2065, 3845];
    
    Print("Testing A174511 computation...\n");
    Print("================================\n");
    
    for n in [1..Minimum(maxN, Length(known))] do
        result := ComputeA174511Direct(n);
        if result = known[n] then
            Print("a(", n, ") = ", result, " ✓\n");
        else
            Print("a(", n, ") = ", result, " WRONG! Expected ", known[n], "\n");
        fi;
    od;
end;

###############################################################################
# Main entry point when running as script
###############################################################################

Print("A174511 computation loaded.\n");
Print("Usage:\n");
Print("  ComputeA174511(n)       - Compute a(n) using best available method\n");
Print("  ComputeA174511Direct(n) - Use direct enumeration (works for n <= ~11)\n");
Print("  ComputeA174511Simple(n) - Simplest method (slow but correct)\n");
Print("  TestA174511(maxN)       - Test against known values\n");
Print("\n");
Print("WARNING: Do not test with n > 8 in interactive mode - it may hang.\n");
Print("For n >= 12, run from command line with: gap -o 16g\n");
