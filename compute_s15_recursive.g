###############################################################################
#
# compute_s15_recursive.g - Recursive maximal subgroup decomposition for S15
#
# When ConjugacyClassesSubgroups fails (OOM) on a large group M, we recursively
# decompose it through its own maximal subgroups, down to "leaf" groups small
# enough for direct computation.
#
# Every subgroup of M is contained in some maximal subgroup of M.
# So we enumerate maxsubs of M, and recursively decompose those too,
# until each group is below MAX_DIRECT_ORDER.
#
# The recursion tree's leaves are groups where ConjugacyClassesSubgroups will
# succeed. The non-leaf internal nodes are groups that ARE subgroups of S15
# themselves (so they contribute to the final count).
#
# Depends on: compute_s14_maxsub.g (for ComputeInvariantKey, BuildIntransitiveMaxSub,
#             BuildWreathMaxSub, ComputeSubgroupsOfMaxSub)
#
###############################################################################

MAXSUB_BASE := "/cygdrive/c/Users/jeffr/Downloads/Symmetric Groups";
MAXSUB_OUTPUT := Concatenation(MAXSUB_BASE, "/maxsub_output_s15");
MAXSUB_CACHE := Concatenation(MAXSUB_BASE, "/conjugacy_cache");

# Load base functions
Read(Concatenation(MAXSUB_BASE, "/compute_s14_maxsub.g"));
MAXSUB_OUTPUT := Concatenation(MAXSUB_BASE, "/maxsub_output_s15");

###############################################################################
# MaximalSubgroupClassesReps(G)
#
# Compute representatives of the conjugacy classes of maximal subgroups of G.
# Uses GAP's built-in MaximalSubgroupClassReps.
# Returns a list of groups (one per conjugacy class of maximal subgroups).
###############################################################################

MaxSubReps := function(G)
    local reps;
    reps := MaximalSubgroupClassReps(G);
    return reps;
end;

###############################################################################
# MaxSubsOfIntransitiveProduct(k, m, n)
#
# Enumerate maximal subgroups of S_k x S_m acting on {1,...,n}.
# Here k+m <= n (with remaining points fixed).
#
# Maximal subgroups of S_k x S_m are:
#   Type 1: Reduce the S_k factor:
#     - A_k x S_m (if k >= 2)
#     - (S_i x S_{k-i}) x S_m for 1 <= i <= floor(k/2)
#   Type 2: Reduce the S_m factor:
#     - S_k x A_m (if m >= 2)
#     - S_k x (S_j x S_{m-j}) for 1 <= j <= floor(m/2)
#   Type 3: "Diagonal" maximal subgroup (index 2 subdirect product):
#     - {(sigma, tau) in S_k x S_m : sign(sigma) = sign(tau)}
#     = generated by A_k x A_m plus one mixed odd permutation
#     (This only exists when both k >= 2 and m >= 2)
#
# Note: Wreath products and primitive groups inside each factor are also
# maximal subgroups, but these are covered by MaximalSubgroupClassReps
# when we construct the group directly. For the recursive approach, we
# primarily need the intransitive sub-products since those are the ones
# that recursively decompose.
#
# For simplicity and correctness, we just use MaximalSubgroupClassReps(M)
# on the concrete permutation group M = S_k x S_m, which handles all types.
###############################################################################

MaxSubsOfIntransitiveProduct := function(k, m, n)
    local M, reps, result, i, H, label;

    Print("Computing maximal subgroups of S", k, " x S", m,
          " (degree ", n, ")...\n");

    M := BuildIntransitiveMaxSub(k, n);
    # Sanity check: order should be k! * m!
    if Size(M) <> Factorial(k) * Factorial(n - k) then
        Print("WARNING: Order mismatch! Expected ", Factorial(k) * Factorial(n-k),
              " got ", Size(M), "\n");
    fi;

    reps := MaxSubReps(M);
    Print("  Found ", Length(reps), " maximal subgroup classes\n");

    result := [];
    for i in [1..Length(reps)] do
        H := reps[i];
        label := Concatenation("maxsub_S", String(k), "xS", String(m),
                               "_class_", String(i));
        Add(result, rec(
            group := H,
            order := Size(H),
            label := label,
            parent := Concatenation("S", String(k), "xS", String(m))
        ));
        if Length(reps) <= 30 or i mod 10 = 0 then
            Print("  MaxSub #", i, ": order ", Size(H),
                  ", degree ", LargestMovedPoint(H), "\n");
        fi;
    od;

    return result;
end;

###############################################################################
# EnumerateLeaves(G, label, maxOrder, depth, leaves, nonleaves, n)
#
# Recursive function that walks the maximal subgroup tree of G.
#
# If Size(G) <= maxOrder, G is a "leaf" - we can compute its subgroup lattice
# directly. Add it to leaves.
#
# If Size(G) > maxOrder, G itself is a subgroup of S_n (add to nonleaves),
# and we recursively enumerate maximal subgroups of G.
#
# Parameters:
#   G          - a permutation group (subgroup of S_n)
#   label      - human-readable label for this group
#   maxOrder   - threshold: groups with order <= this are leaves
#   depth      - current recursion depth (for logging)
#   leaves     - output: list of rec(group, label, order, depth, genImages)
#   nonleaves  - output: list of rec(genImages, inv, label) - groups that ARE
#                subgroups of S_n but are too big for direct lattice computation
#   n          - degree of the ambient symmetric group
#   visited    - record of already-visited group orders+sizes (dedup within tree)
#
# Returns: nothing (modifies leaves and nonleaves in place)
###############################################################################

EnumerateLeaves := function(G, label, maxOrder, depth, leaves, nonleaves, n, visited)
    local indent, ord, maxsubs, i, H, childLabel, gens, genImages, g, inv,
          visitKey, orbStruct, rawKey, ch, sanitized, j;

    indent := ListWithIdenticalEntries(depth * 2, ' ');
    ConvertToStringRep(indent);
    ord := Size(G);

    # Quick orbit structure for dedup key
    orbStruct := ComputeOrbitStructure(G, n);
    rawKey := Concatenation(String(ord), "_", String(orbStruct), "_",
                              String(NrConjugacyClasses(G)));

    # Sanitize key: GAP record field names must be valid identifiers
    # Replace all non-alphanumeric chars with underscores, prefix with "v"
    sanitized := "v";
    for j in [1..Length(rawKey)] do
        ch := rawKey[j];
        if ch in "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_" then
            Append(sanitized, [ch]);
        else
            Append(sanitized, "_");
        fi;
    od;
    # Truncate if too long for GAP record field names (max 1023 chars)
    if Length(sanitized) > 1000 then
        sanitized := sanitized{[1..1000]};
    fi;
    visitKey := sanitized;

    # Check if we've already visited an isomorphic group at this level
    if IsBound(visited.(visitKey)) then
        visited.(visitKey) := visited.(visitKey) + 1;
        Print(indent, "SKIP (visited): ", label, " order=", ord, "\n");
        return;
    fi;
    visited.(visitKey) := 1;

    if ord <= maxOrder then
        # LEAF: small enough for direct ConjugacyClassesSubgroups
        gens := GeneratorsOfGroup(G);
        genImages := [];
        for g in gens do
            Add(genImages, ListPerm(g, n));
        od;

        Add(leaves, rec(
            genImages := genImages,
            order := ord,
            label := label,
            depth := depth
        ));

        Print(indent, "LEAF: ", label, " order=", ord, "\n");
        return;
    fi;

    # NON-LEAF: too big, add G itself as a subgroup, then recurse into maxsubs
    gens := GeneratorsOfGroup(G);
    genImages := [];
    for g in gens do
        Add(genImages, ListPerm(g, n));
    od;
    inv := ComputeInvariantKey(G, n);

    Add(nonleaves, rec(
        genImages := genImages,
        inv := inv,
        label := label,
        order := ord
    ));

    Print(indent, "NON-LEAF: ", label, " order=", ord,
          " -> recursing into maximal subgroups\n");

    # Get maximal subgroup class reps of G
    maxsubs := MaxSubReps(G);
    Print(indent, "  Found ", Length(maxsubs), " maximal subgroup classes\n");

    for i in [1..Length(maxsubs)] do
        H := maxsubs[i];
        childLabel := Concatenation(label, "/ms", String(i));

        # Recurse
        EnumerateLeaves(H, childLabel, maxOrder, depth + 1,
                         leaves, nonleaves, n, visited);

        # Periodic GC
        if i mod 20 = 0 then
            GASMAN("collect");
        fi;
    od;
end;

###############################################################################
# EnumerateAllLeaves(maxOrder, n)
#
# Top-level function: enumerate all leaves needed for S_n computation.
# Processes each maximal subgroup of S_n that is too large for direct
# computation.
#
# Returns: rec(leaves, nonleaves, direct) where:
#   leaves    - groups needing ConjugacyClassesSubgroups
#   nonleaves - groups that are S_n subgroups but too large for direct lattice
#   direct    - groups small enough to compute directly at the top level
###############################################################################

EnumerateAllLeaves := function(maxOrder, n, skipLabels)
    local maxsubs, leaves, nonleaves, direct, visited, i, M, label, ord,
          skipped;

    Print("=== Enumerating leaves for S", n, " with MAX_DIRECT_ORDER = ", maxOrder, " ===\n\n");

    maxsubs := EnumerateMaximalSubgroups(n);
    Print("Found ", Length(maxsubs), " maximal subgroup types of S", n, "\n\n");

    leaves := [];
    nonleaves := [];
    direct := [];
    visited := rec();
    skipped := [];

    for i in [1..Length(maxsubs)] do
        M := maxsubs[i].group;
        label := maxsubs[i].label;
        ord := Size(M);

        Print("\n--- Maximal subgroup ", i, "/", Length(maxsubs),
              ": ", label, " (order ", ord, ") ---\n");

        # Skip groups handled by other scripts (direct workers, cache, etc.)
        if label in skipLabels then
            Print("  SKIP: handled by direct worker script\n");
            Add(skipped, label);
            continue;
        fi;

        if ord <= maxOrder then
            # Small enough for direct computation
            Add(direct, rec(
                group := M,
                label := label,
                order := ord,
                type := maxsubs[i].type
            ));
            Print("  DIRECT: will compute lattice directly\n");
        else
            # Too large: recursively enumerate leaves
            EnumerateLeaves(M, label, maxOrder, 1, leaves, nonleaves, n, visited);
        fi;
    od;

    Print("\n=== Enumeration Summary ===\n");
    Print("  Skipped (handled separately): ", Length(skipped), " - ", skipped, "\n");
    Print("  Direct (top-level small): ", Length(direct), "\n");
    Print("  Leaves (recursive small):  ", Length(leaves), "\n");
    Print("  Non-leaves (large S", n, " subgroups): ", Length(nonleaves), "\n");
    Print("  Total groups to compute lattices: ",
          Length(direct) + Length(leaves), "\n");

    return rec(
        leaves := leaves,
        nonleaves := nonleaves,
        direct := direct
    );
end;

###############################################################################
# SaveEnumerationResults(results, outputDir, n)
#
# Save the enumeration results to files for later processing.
# Creates:
#   - leaves.g:     leaf groups (generator images + metadata)
#   - nonleaves.g:  non-leaf groups (with invariant keys, ready for Phase B)
#   - direct.g:     groups for direct computation (labels + orders)
#   - summary.txt:  human-readable summary
###############################################################################

SaveEnumerationResults := function(results, outputDir, n)
    local leavesFile, nonleavesFile, directFile, summaryFile,
          i, entry, gens, g;

    # Save leaves
    leavesFile := Concatenation(outputDir, "/leaves.g");
    Print("Saving ", Length(results.leaves), " leaves to ", leavesFile, "\n");
    PrintTo(leavesFile, "# Leaf groups for S", n, " recursive decomposition\n");
    AppendTo(leavesFile, "# These groups are small enough for ConjugacyClassesSubgroups\n");
    AppendTo(leavesFile, "# Count: ", Length(results.leaves), "\n");
    AppendTo(leavesFile, "leaf_groups := [\n");
    for i in [1..Length(results.leaves)] do
        entry := results.leaves[i];
        if i > 1 then
            AppendTo(leavesFile, ",\n");
        fi;
        AppendTo(leavesFile, "  rec(genImages := ", entry.genImages,
                 ", order := ", entry.order,
                 ", label := \"", entry.label,
                 "\", depth := ", entry.depth, ")");
    od;
    AppendTo(leavesFile, "\n];\n");

    # Save non-leaves
    nonleavesFile := Concatenation(outputDir, "/nonleaves.g");
    Print("Saving ", Length(results.nonleaves), " non-leaves to ", nonleavesFile, "\n");
    PrintTo(nonleavesFile, "# Non-leaf groups for S", n, " dedup\n");
    AppendTo(nonleavesFile, "# These groups are S", n, " subgroups themselves\n");
    AppendTo(nonleavesFile, "# They are too large for direct lattice computation\n");
    AppendTo(nonleavesFile, "# Count: ", Length(results.nonleaves), "\n");
    AppendTo(nonleavesFile, "nonleaf_groups := [\n");
    for i in [1..Length(results.nonleaves)] do
        entry := results.nonleaves[i];
        if i > 1 then
            AppendTo(nonleavesFile, ",\n");
        fi;
        AppendTo(nonleavesFile, "  rec(gens := ", entry.genImages,
                 ", inv := ", entry.inv,
                 ", source := \"", entry.label, "\")");
    od;
    AppendTo(nonleavesFile, "\n];\n");

    # Save direct list
    directFile := Concatenation(outputDir, "/direct.g");
    Print("Saving ", Length(results.direct), " direct groups to ", directFile, "\n");
    PrintTo(directFile, "# Groups for direct computation (small maximal subgroups)\n");
    AppendTo(directFile, "# Count: ", Length(results.direct), "\n");
    AppendTo(directFile, "direct_groups := [\n");
    for i in [1..Length(results.direct)] do
        entry := results.direct[i];
        gens := GeneratorsOfGroup(entry.group);
        if i > 1 then
            AppendTo(directFile, ",\n");
        fi;
        AppendTo(directFile, "  rec(genImages := ",
                 List(gens, g -> ListPerm(g, n)),
                 ", order := ", entry.order,
                 ", label := \"", entry.label,
                 "\", type := \"", entry.type, "\")");
    od;
    AppendTo(directFile, "\n];\n");

    Print("Enumeration results saved.\n");
end;

###############################################################################
# ComputeLeafSubgroups(genImages, label, outputFile, n)
#
# Reconstruct a leaf group from generator images, compute its subgroup lattice,
# and save results in the standard maxsub_results format.
#
# This is the worker function called for each leaf.
###############################################################################

ComputeLeafSubgroups := function(genImages, label, outputFile, n)
    local gens, G, count;

    # Reconstruct group
    gens := List(genImages, PermList);
    if Length(gens) = 0 then
        G := Group(());
    else
        G := Group(gens);
    fi;

    Print("Leaf worker: ", label, "\n");
    Print("  Order: ", Size(G), "\n");
    Print("  LargestMovedPoint: ", LargestMovedPoint(G), "\n");

    # Use the existing ComputeSubgroupsOfMaxSub function
    count := ComputeSubgroupsOfMaxSub(G, label, outputFile, n);

    return count;
end;

Print("compute_s15_recursive.g loaded successfully.\n");
